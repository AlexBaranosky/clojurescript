;;  Copyright (c) Rich Hickey. All rights reserved.
;;  The use and distribution terms for this software are covered by the
;;  Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;;  which can be found in the file epl-v10.html at the root of this distribution.
;;  By using this software in any fashion, you are agreeing to be bound by
;;  the terms of this license.
;;  You must not remove this notice, or any other, from this software.

(ns ^{:doc "Receive - Eval - Print - Loop

  Receive a block of JS (presumably generated by a ClojureScript compiler)
  Evaluate it naively
  Print the result of evaluation to a string
  Send the resulting string back to the server Loop!"

      :author "Bobby Calderwood and Alex Redington"}
  clojure.browser.repl
  (:require [clojure.browser.net   :as net]
            [clojure.browser.event :as event]))

(defn log-obj [obj]
  (.log js/console obj))

(defn evaluate-javascript
  "Process a single block of JavaScript received from the server"
  [block]
  (log-obj (str "evaluating: " block))
  (let [result (try (js* "eval(~{block})")
                    (catch js/Error e (pr-str e)))]
    (log-obj (str "result: " result))
    result))

(defn send-result [connection url data]
  (net/transmit connection url "POST" data nil 0))

(defn fetch-block [connection url]
  (net/transmit connection url "GET" nil nil 0))

(defn start-evaluator
  "Start the REPL server connection."
  [url]
  (if-let [config (.getParameterValue
                   (goog.Uri. js/window.location.href)
                   "xpc")]
    (let [repl-connection     (net/xpc-connection config)
          inbound-connection  (net/xhr-connection)
          outbound-connection (net/xhr-connection)]
      (net/register-service repl-connection
                            :post-results
                            (partial send-result
                                     outbound-connection))
      (event/listen outbound-connection
                    :ready
                    (fn [e]
                      (fetch-block inbound-connection url)))
      (event/listen inbound-connection
                    :success
                    (fn [e]
                      (evaluate-javascript
                       (.getResponseText e/currentTarget
                                         ())))))
    (js/alert "No 'xpc' param provided to child iframe.")))

;; We should refactor this to use two separate XhrIo objects, one for
;; GETs, one for POSTs, resetting each other in a little state-machine

(defn connect-repl
  "Connects to a REPL server in the context of an HTML document. After
  the connection is made, the REPL will evaluate forms in the context
  of the document."
  ([repl-server-url]
     (connect-repl repl-server-url (js/document)))
  ([repl-server-url document]
     (let [repl-connection (net/xpc-connection
                            {:peer_uri repl-server-url})]
       (net/register-service repl-connection
                             :evaluate-javascript
                             (fn [js]
                               (net/transmit
                                repl-connection
                                :send-result
                                (evaluate-javascript js))))
       (net/connect repl-connection
                    js/window
                    (fn []
                      (js/alert "Working!"))
                    (fn [iframe]
                      (set! iframe.style.display
                            "none"))))))

(comment
  (defn log [& args]
    (.log js/console (apply pr-str args)))

  (defn log-obj [obj]
    (.log js/console obj))

  (def result-id (atom 0))
  (def result    (atom nil))

  (defn next-result!
    []
    (swap! result-id inc)
    (reset! result nil))

  (defn input-uri [base-uri]
    (str base-uri "/javascript/" @result-id))

  (defn output-uri [base-uri]
    (str base-uri "/clojurescript/out/" @result-id))

  (defn get-block
    "Gets a single block of JavaScript from the server"
    [connection base-uri]
    (log "(get-block " connection " " base-uri ")")
    (net/transmit connection (input-uri base-uri)))

  (defn post-result
    "Posts an evaluated block of ClojureScript to the server"
    [connection base-uri]
    (log "(post-result " connection " " base-uri " " @result ")")
    (net/transmit connection (output-uri base-uri) "POST" @result))

  (defn process-block
    "Process a single block of JavaScript received from the server"
    [block]
    (log-obj (str "evaluating: " block))
    (js* "eval(~{block})"))

  #_(defmacro with-timeout
      [ms & body]
      `(let [f# (fn [] ~@body)]
         (js/setTimeout f# ~ms)))

  (defn start-repl
    "Start the REPL loop"
    [base-uri]
    (let [connection (net/xhr-connection)]
      (event/listen connection
                    :ready
                    (fn [e]
                      (if @result
                        (post-result connection base-uri)
                        (js/setTimeout
                         (fn []
                           (get-block connection base-uri))
                         100))))

      (event/listen-once connection
                         :success
                         (fn [_]
                           (log "one time only")
                           (event/listen connection
                                         :success
                                         (fn [e]
                                           (log @result)
                                           (if @result
                                             (next-result!)
                                             (reset! result
                                                     (process-block
                                                      (.getResponseText e/target ()))))))))



      (js/setTimeout
       (fn []
         (net/transmit connection
                       (str base-uri "/clients")
                       "POST"))
       100))))
